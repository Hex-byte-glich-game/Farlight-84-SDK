// Class ProceduralMeshComponent.KismetProceduralMeshLibrary
// Size: 0x28 (Inherited: 0x28)
struct UKismetProceduralMeshLibrary : UBlueprintFunctionLibrary {

	void SliceProceduralMesh(struct UProceduralMeshComponent* InProcMesh, struct FVector PlanePosition, struct FVector PlaneNormal, bool bCreateOtherHalf, struct UProceduralMeshComponent*& OutOtherHalfProcMesh, enum class EProcMeshSliceCapOption CapOption, struct UMaterialInterface* CapMaterial); // Function ProceduralMeshComponent.KismetProceduralMeshLibrary.SliceProceduralMesh // (Exec|Native|Event|NetResponse|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145b800
	void GetSectionFromStaticMesh(struct UStaticMesh* InMesh, int32_t LODIndex, int32_t SectionIndex, struct TArray<struct FVector>& Vertices, struct TArray<int32_t>& Triangles, struct TArray<struct FVector>& Normals, struct TArray<struct FVector2D>& UVs, struct TArray<struct FProcMeshTangent>& Tangents); // Function ProceduralMeshComponent.KismetProceduralMeshLibrary.GetSectionFromStaticMesh // (Net|NetReliableNetRequest|Event|NetResponse|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145ba40
	void GetSectionFromProceduralMesh(struct UProceduralMeshComponent* InProcMesh, int32_t SectionIndex, struct TArray<struct FVector>& Vertices, struct TArray<int32_t>& Triangles, struct TArray<struct FVector>& Normals, struct TArray<struct FVector2D>& UVs, struct TArray<struct FProcMeshTangent>& Tangents); // Function ProceduralMeshComponent.KismetProceduralMeshLibrary.GetSectionFromProceduralMesh // (Net|NetRequest|Exec|Native|NetResponse|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145ba40
	void GenerateBoxMesh(struct FVector BoxRadius, struct TArray<struct FVector>& Vertices, struct TArray<int32_t>& Triangles, struct TArray<struct FVector>& Normals, struct TArray<struct FVector2D>& UVs, struct TArray<struct FProcMeshTangent>& Tangents); // Function ProceduralMeshComponent.KismetProceduralMeshLibrary.GenerateBoxMesh // (NetReliableNative|NetResponse|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145ba40
	void CreateGridMeshWelded(int32_t NumX, int32_t NumY, struct TArray<int32_t>& Triangles, struct TArray<struct FVector>& Vertices, struct TArray<struct FVector2D>& UVs, float GridSpacing); // Function ProceduralMeshComponent.KismetProceduralMeshLibrary.CreateGridMeshWelded // (NetReliableExec|Event|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145ba40
	void CreateGridMeshTriangles(int32_t NumX, int32_t NumY, bool bWinding, struct TArray<int32_t>& Triangles); // Function ProceduralMeshComponent.KismetProceduralMeshLibrary.CreateGridMeshTriangles // (Net|NetRequest|Event|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145ba40
	void CreateGridMeshSplit(int32_t NumX, int32_t NumY, struct TArray<int32_t>& Triangles, struct TArray<struct FVector>& Vertices, struct TArray<struct FVector2D>& UVs, struct TArray<struct FVector2D>& UV1s, float GridSpacing); // Function ProceduralMeshComponent.KismetProceduralMeshLibrary.CreateGridMeshSplit // (NetReliableExec|Native|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145ba40
	void CopyProceduralMeshFromStaticMeshComponent(struct UStaticMeshComponent* StaticMeshComponent, int32_t LODIndex, struct UProceduralMeshComponent* ProcMeshComponent, bool bCreateCollision); // Function ProceduralMeshComponent.KismetProceduralMeshLibrary.CopyProceduralMeshFromStaticMeshComponent // (NetReliableNetRequest|Native|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145ba40
	void ConvertQuadToTriangles(struct TArray<int32_t>& Triangles, int32_t Vert0, int32_t Vert1, int32_t Vert2, int32_t Vert3); // Function ProceduralMeshComponent.KismetProceduralMeshLibrary.ConvertQuadToTriangles // (Net|NetReliableNetRequest|Exec|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145ba40
	void CalculateTangentsForMesh(struct TArray<struct FVector>& Vertices, struct TArray<int32_t>& Triangles, struct TArray<struct FVector2D>& UVs, struct TArray<struct FVector>& Normals, struct TArray<struct FProcMeshTangent>& Tangents); // Function ProceduralMeshComponent.KismetProceduralMeshLibrary.CalculateTangentsForMesh // (Net|NetReliableNetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145ba40
};

// Class ProceduralMeshComponent.ProceduralMeshComponent
// Size: 0x5e0 (Inherited: 0x580)
struct UProceduralMeshComponent : UMeshComponent {
	bool bUseComplexAsSimpleCollision; // 0x580(0x01)
	bool bUseAsyncCooking; // 0x581(0x01)
	char pad_582[0x6]; // 0x582(0x06)
	struct UBodySetup* ProcMeshBodySetup; // 0x588(0x08)
	struct TArray<struct FProcMeshSection> ProcMeshSections; // 0x590(0x10)
	struct TArray<struct FKConvexElem> CollisionConvexElems; // 0x5a0(0x10)
	struct FBoxSphereBounds LocalBounds; // 0x5b0(0x1c)
	char pad_5CC[0x4]; // 0x5cc(0x04)
	struct TArray<struct UBodySetup*> AsyncBodySetupQueue; // 0x5d0(0x10)

	void UpdateMeshSection_LinearColor(int32_t SectionIndex, struct TArray<struct FVector>& Vertices, struct TArray<struct FVector>& Normals, struct TArray<struct FVector2D>& UV0, struct TArray<struct FVector2D>& UV1, struct TArray<struct FVector2D>& UV2, struct TArray<struct FVector2D>& UV3, struct TArray<struct FLinearColor>& VertexColors, struct TArray<struct FProcMeshTangent>& Tangents); // Function ProceduralMeshComponent.ProceduralMeshComponent.UpdateMeshSection_LinearColor // (NetRequest|Exec|Static|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145e500
	void UpdateMeshSection(int32_t SectionIndex, struct TArray<struct FVector>& Vertices, struct TArray<struct FVector>& Normals, struct TArray<struct FVector2D>& UV0, struct TArray<struct FColor>& VertexColors, struct TArray<struct FProcMeshTangent>& Tangents); // Function ProceduralMeshComponent.ProceduralMeshComponent.UpdateMeshSection // (Net|Static|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145b800
	void SetMeshSectionVisible(int32_t SectionIndex, bool bNewVisibility); // Function ProceduralMeshComponent.ProceduralMeshComponent.SetMeshSectionVisible // (Net|NetRequest|Native|Event|NetResponse|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145b800
	bool IsMeshSectionVisible(int32_t SectionIndex); // Function ProceduralMeshComponent.ProceduralMeshComponent.IsMeshSectionVisible // (Net|NetReliableNative|Event|NetResponse|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145b800
	int32_t GetNumSections(); // Function ProceduralMeshComponent.ProceduralMeshComponent.GetNumSections // (NetRequest|Exec|Native|NetResponse|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145b800
	void CreateMeshSection_LinearColor(int32_t SectionIndex, struct TArray<struct FVector>& Vertices, struct TArray<int32_t>& Triangles, struct TArray<struct FVector>& Normals, struct TArray<struct FVector2D>& UV0, struct TArray<struct FVector2D>& UV1, struct TArray<struct FVector2D>& UV2, struct TArray<struct FVector2D>& UV3, struct TArray<struct FLinearColor>& VertexColors, struct TArray<struct FProcMeshTangent>& Tangents, bool bCreateCollision); // Function ProceduralMeshComponent.ProceduralMeshComponent.CreateMeshSection_LinearColor // (NetResponse|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145b800
	void CreateMeshSection(int32_t SectionIndex, struct TArray<struct FVector>& Vertices, struct TArray<int32_t>& Triangles, struct TArray<struct FVector>& Normals, struct TArray<struct FVector2D>& UV0, struct TArray<struct FColor>& VertexColors, struct TArray<struct FProcMeshTangent>& Tangents, bool bCreateCollision); // Function ProceduralMeshComponent.ProceduralMeshComponent.CreateMeshSection // (Net|NetReliableNative|Event|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145b800
	void ClearMeshSection(int32_t SectionIndex); // Function ProceduralMeshComponent.ProceduralMeshComponent.ClearMeshSection // (Net|NetRequest|Exec|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145b800
	void ClearCollisionConvexMeshes(); // Function ProceduralMeshComponent.ProceduralMeshComponent.ClearCollisionConvexMeshes // (Net|NetRequest|Exec|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145b800
	void ClearAllMeshSections(); // Function ProceduralMeshComponent.ProceduralMeshComponent.ClearAllMeshSections // (NetRequest|Exec|NetMulticast|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145b800
	void AddCollisionConvexMesh(struct TArray<struct FVector> ConvexVerts); // Function ProceduralMeshComponent.ProceduralMeshComponent.AddCollisionConvexMesh // (Net|NetReliableNetRequest|Exec|Native|Event|NetResponse|Static|MulticastDelegate|Private|Protected|BlueprintCallable|BlueprintEvent|NetValidate) // @ game+0xffff822f3145b800
};

